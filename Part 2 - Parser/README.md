# Parser Design Documentation

This is a parser for a subset of C programming language (nanoC), implemented using Bison and Flex. 

## Table of Contents

- [Bison Specification](#bison-specification)
  - [Design Choices](#design-choices)
  - [The Working](#the-working)
  - [Main Function](#main-function)
  - [Miscellaneous](#miscellaneous)
- [Usage](#usage)

## Bison Specification

### Design Choices

**Lexical Analysis (%token):**  
The specification defines various tokens such as keywords (e.g., `IF`, `ELSE`), data types (e.g., `INT`, `CHAR`), and operators (e.g., `MULTIPLICATION`, `LOGICAL AND`). These tokens are fundamental building blocks for parsing the programming language. They are defined in `31_A3.l` file. 

We have modified the lexer from assignment 2 by basically defining the tokens in depth (for example, destructuring the KEYWORD tokens and the PUNCTUATOR tokens and generated several cases from them). This is done so that we can use specific tokens for specific scenarios in the parser (according to the rules). 

The changes in the lexer file from the previous assignment are:
1. We removed the DOT_CASE since we aren’t focused on terminating the program on getting invalid inputs.
2. We unpacked the PUNCTUATOR and KEYWORD rules and created separate rules for them and added some new ones like MULTIPLICATION.
3. We have used ’?’ in our rule of string literals to allow for empty strings.

**Grammar Rules:**  
The specification outlines the structure of the language using grammar rules. For example, it defines rules for primary expressions, postfix expressions, unary expressions, and more. Each rule specifies how elements in the language can be combined and structured according to the assignment document.

**Precedence and Associativity (%nonassoc):**  
Precedence levels and associativity are deployed for resolving ambiguities in the grammar. Our Bison specification uses %nonassoc to indicate non-associative operators and deal with shift-reduce conflicts.

**Actions (printf(...)):**  
Actions are embedded within grammar rules using {}. These actions define what should happen when a particular rule is matched during parsing. As required, we are just printing the non-terminal associated with the matched rules.

### The Working

**Lexical Analysis:**  
The input source code is first tokenized by the lexer. The lexer identifies keywords, operators, and literals and produces a stream of tokens.

**Parsing:**  
Bison processes the token stream generated by the lexer based on the grammar rules defined in the specification. It uses these rules to recognize the syntax of the input source code and generate a parse tree.

**Actions:**  
Actions defined in the specification are executed as the parser recognizes and processes grammar rules.

**Shift-Reduce Conflict Resolution:**  
Bison handles shift-reduce conflicts using precedence and associativity rules. The `%nonassoc` directive is used to indicate non-associative operators that help in conflict resolution.

### Main Function

When a program is compiled and executed, the ‘main‘ function serves as the entry point, and its primary responsibility is to initiate the parsing process. This is accomplished by calling the ‘yyparse()‘ function, which is an automatically generated function by Bison based on the grammar rules and actions defined in our parser specification. The ‘yyparse()‘ function reads and analyzes the input source code according to the grammar rules, and it orchestrates the parsing of the entire program. Once parsing is complete, the ‘main‘ function typically returns an appropriate exit status, such as 0, indicating that the parsing process was successful.

### Miscellaneous

- We use `extern int yylex();` to tokenize the input source code.
- We use `extern char* yytext;` to store the text associated with the currently matched token.
- `void yyerror(char *s);` is used to report parsing errors or provide error messages during the parsing process.
- `%union` is used to hold values associated with various token types to have more flexible and complex data associated with tokens.


## Usage
The project is pre-compiled and so, it can be tested against the file 'test.nc' using the command './parser < test.nc' for linux. Manual compilation can be done using the Makefile using 'make build' or using the following commands:

1. `flex -o lex.yy.c 31_A3.l` (Creeates lex.yy.c)
2. `bison 31_A3.y --defines=31_A3.tab.h -o 31_A3.tab.c` (Creates tab.c and tab.h files)
3. `gcc -o parser lex.yy.c 31_A3.tab.c 31_A3.c -lfl`

A run for a sample C program is given below:
```c
int main() {
    int x;
    int y;
    int z;
    
    return 0;
}
```
```
type-specifier
direct-declarator
declarator
type-specifier
direct-declarator
declarator
init-declarator
declaration
block-item
block-item-list
type-specifier
direct-declarator
declarator
init-declarator
declaration
block-item
block-item-list
type-specifier
direct-declarator
declarator
init-declarator
declaration
block-item
block-item-list
primary-expression
postfix-expression
unary-expression
multiplicative-expression
additive-expression
relational-expression
equality-expression
logical-AND-expression
logical-OR-expression
conditional-expression
assignment-expression
expression
jump-statement
statement
block-item
block-item-list
compound-statement
function-definition
external-declaration
translation-unit
```